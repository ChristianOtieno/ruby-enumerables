#!/usr/bin/env ruby

module Enumerable
  def my_each
    return to_enum unless block_given?

    entry = is_a?(Range) ? to_a : self
    i = 0
    while i < size
      yield(self[i])
      i += 1
    end
    entry
  end

  def my_each_with_index
    return to_enum unless block_given?

    entry = is_a?(Range) ? to_a : self

    i = 0
    while i < size
      yield(self[i], i)
      i += 1
    end
    entry
  end

  def my_select
    return to_enum unless block_given?

    i = 0
    arr = []
    while i < size
      arr << self[i] if yield(self[i])
      i += 1
    end
    arr
  end

  def my_all?(arg = nil)
    if block_given?
      my_each { |e| return false unless yield(e) }
    end
    if arg.nil?
      my_each { |e| return false unless e }
      return true
    end
    my_each { |e| return false unless check_validity(e, arg) }
    true
  end

  def my_any?(arg = nil, &proc)
    if block_given?
      my_each { |e| return true if proc.nil? ? proc.call(e) : yield(e) }
    else
      my_each { |e| return true if arg.nil? ? elem : check_validity(e, arg) }
    end
    false
  end

  def my_none?(pattern = nil, &proc)
    !my_any?(pattern, &proc)
  end

  def my_count(num = nil)
    count = 0
    if num
      my_each { |e| count += 1 if e == num }
    elsif block_given?
      my_each { |e| count += 1 if yield(e) }
    else
      count = length
    end
    count
  end


  def my_map(block = nil)
    return to_enum unless block_given?

    arr = []
    if block
      my_each_with_index { |e, i| arr[i] = block.call(e) }
    else
      my_each_with_index { |e, i| arr[i] = yield(e) }
    end
    arr
  end

  def my_inject(val)
    my_each { |e| val = yield(val, e) }
    val
  end

  def multiply_els(array)
    array.my_inject(1) { |x, y| x * y }
  end

  def check_validity(elem, param)
    return elem.is_a?(param) if param.is_a?(Class)

    if param.is_a?(Regexp)
      return false if elem.is_a?(Numeric)

      return param.match(entry)
    end
    (elem == param)
  end
end

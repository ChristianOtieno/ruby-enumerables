#!/usr/bin/env ruby

# frozen_string_literal: true

module Enumerable
  def my_each
    return to_enum unless block_given?

    entry = is_a?(Range) ? to_a : self
    i = 0
    while i < size
      yield(self[i])
      i += 1
    end
    entry
  end

  # [1,2,3,4].my_each {|x| puts x * 2}
  # output = 2 4 6 8
  

  def my_each_with_index
    return to_enum unless block_given?

    entry = is_a?(Range) ? to_a : self

    i = 0
    while i < size
      yield(self[i], i)
      i += 1
    end
    entry
  end
[4,5,3,2].my_each_with_index {|val,index| puts "index: #{index} for #{val}" if val < 10}
# output = 2 4 6 8

  def my_select
    return to_enum unless block_given?

    i = 0
    arr = []
    while i < size
      arr << self[i] if yield(self[i])
      i += 1
    end
    arr
  end

  def my_all?(arr)

    elem = true
    i = 0
    while i < arr.length
      elem = false unless yield(arr[i])
      i += 1
    end
    elem
  end

  def my_any?
    return to_enum unless block_given?

    i = 0
    while i < size
      return true if yield(self[i])

      i += 1
    end
    false
  end

  def my_none?
    return to_enum unless block_given?

    elem = true

    i = 0
    while i < size
      elem = false if yield(self[i])
      i += 1
    end
    elem
  end

  def my_count
    return to_enum unless block_given?

    elem = 0

    i = 0
    while i < size

      elem += 1 if yield(self[i])
      i += 1
    end
    elem
  end

  def my_map(arr, prc = nil)
    elem = []

    i = 0
    while i < arr.length

      if block_given?
        yield(arr[i])
      else
        elem << prc.call(arr[i])
      end
      i += 1
    end
    elem
  end

  def my_inject(arr)
    elem = arr[0]

    i = 0
    while i < arr.length
      elem = yield(elem, arr[i])
      i += 1
    end
    elem
  end

  def multiply_els(arr)
    my_inject(arr) do |_output, x|
      result * x
    end
  end

  def check_validity(elem, param)
    return elem.is_a?(param) if param.is_a?(Class)

    if param.is_a?(Regexp)
      return false if elem.is_a?(Numeric)

      return param.match(entry)
    end
    (elem == param)
  end
end


# module Enumerable
#   def my_each
#     return to_enum(__method__) { size } unless block_given?
#     i = 0
#     self.size.times do
#       yield self[i]
#       i += 1
#     end
#   self
#   end

#   def my_each_with_index
#     return to_enum(__method__) { size } unless block_given?
#     i = 0
#     self.size.times do
#       yield [self[i], i]
#       i += 1
#     end
#   self
#   end

#   def my_select
#     return to_enum(__method__) { size } unless block_given?
#     new_arr = []
#     self.my_each do |x|
#       new_arr << x if yield x
#     end
#     new_arr
#   end

#   def my_all?
#     return true unless block_given?
#     self.my_each do |x|
#       return false unless yield x
#     end
#     true
#   end

#   def my_any?
#     return true unless block_given?
#     self.my_each do |x|
#       return true if yield x
#     end
#     false
#   end

#   def my_none?
#     return false unless block_given?
#     self.my_each do |x|
#       return false if yield x
#     end
#   end

#   def my_count
#     self.size
#   end

#   def my_map
#     return to_enum(__method__) { size } unless block_given?    
#     mapped = []
#     self.my_each do |x|
#       mapped << yield(x)
#     end
#     mapped
#   end

#   def my_inject(acc = nil)
#     copy = self.dup
#     acc ||= copy.shift
#     copy.my_each do |x|
#       acc = yield(acc, x)
#     end
#     acc
#   end

#   def multiply_els
#     self.my_inject { |x, v| x * v }
#   end
# end
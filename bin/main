#!/usr/bin/env ruby
# frozen_string_literal: true

module Enumerable
  def my_each
    return to_enum unless block_given?

    entry = is_a?(Range) ? to_a : self
    i = 0
    while i < size
      yield(self[i])
      i += 1
    end
    entry
  end
  #   [1,2,3,4].my_each {|x| puts x * 2}
  #   output:
  #   2
  #   4
  #   6
  #   8

  def my_each_with_index
    return to_enum unless block_given?

    entry = is_a?(Range) ? to_a : self

    i = 0
    while i < size
      yield(self[i], i)
      i += 1
    end
    entry
  end

  #   [4,5,3,2].my_each_with_index {|val,index| puts "index: #{index} for #{val}" if val < 10}
  #   output:
  #   index: 0 for 4
  #   index: 1 for 5
  #   index: 2 for 3
  #   index: 3 for 2

  def my_select
    return to_enum unless block_given?

    i = 0
    arr = []
    while i < size
      arr << self[i] if yield(self[i])
      i += 1
    end
    arr
  end
  #   puts [1,2,3,4,5,6].my_select(&:even?)
  #   output:
  #   2
  #   4
  #   6

  def my_all?(_arg = nil)
    return true unless block_given?

    my_each do |x|
      return false unless yield x
    end
    true
  end
  #   puts %w[ant bear cat].my_all? { |word| word.length >= 8 }
  #   output:
  #   false

  def my_any?(_arg = nil)
    return true unless block_given?

    i = 0
    while i < size
      return true if yield(self[i])

      i += 1
    end
    false
  end
  #   puts %w[ant bear cat].any? { |word| word.length >= 8 }
  #   output:
  #   false

  def my_none?
    return false unless block_given?

    elem = true

    i = 0
    while i < size
      elem = false if yield(self[i])
      i += 1
    end
    elem
  end
  #   puts  ["ant", "bear", "cat"].my_none? { |word| word.length == 5 }
  #   output:
  #   true

  def my_count(xander = nil)
    count = 0
    if block_given?
      my_each { |e| count += 1 if yield e }
    elsif xander
      my_each { |e| count += 1 if e == xander }
    else
      count = length
    end
    count
  end
  #   ary = [1, 2, 4, 2]
  #   puts ary.my_count               #=> 4
  #   puts ary.my_count(2)            #=> 2
  #   puts ary.my_count{ |x| x%2==0 } #=> 3

  def my_map
    return to_enum :my_map unless block_given?

    i = 0
    arr = []

    while i < size
      array2 << if block_given?
                  yield(self[i])
                else
                  proc.call(self[i])
                end
      i += 1
    end
    arr
  end

  def my_inject(param = nil)
    arr_input = self.class == Range ? to_a : self
    result = param.nil? || param.is_a?(Symbol) ? arr_input[0] : param

    if block_given?
      pointr = param.nil? ? 1 : 0
      arr_input[pointr..-1].my_each do |element|
        result = yield(result, element)
      end
      return result
    end

    arr_input[1..-1].my_each do |element|
      result = result.send(param, element)
    end

    result
  end
  #   puts (5..10).my_inject { |sum, n| sum + n } #=> 45

  def multiply_els
    result = 1
    my_each { |element| result *= element }
    result
  end
  #   array = [2,4,5]
  #   puts array.multiply_els #=> 40

  
end
